{"version":3,"sources":["msavin:mongol/lib/common.js","msavin:mongol/server/methods.js","msavin:mongol/server/utility_functions.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,6D;;AAEA,2B;AACA,E;AACA,sD;AACA,c;;AAEA,C;;AAEA,U;AACA,wC;AACA,wC;AACA,+D;;AAEA,mB;AACA,I;AACA,4B;AACA,mB;AACA,wB;AACA,8G;AACA,c;AACA,uB;AACA,wE;AACA,c;AACA,oB;AACA,qE;AACA,c;AACA,oB;AACA,sE;AACA,c;AACA,oB;AACA,sG;AACA,c;AACA,c;AACA,+B;AACA,c;AACA,K;AACA,I;AACA,4B;AACA,2B;AACA,Y;AACA,uG;AACA,gD;AACA,kC;AACA,sC;AACA,oB;AACA,qC;AACA,a;AACA,W;AACA,uB;AACA,S;AACA,iD;AACA,O;AACA,qB;AACA,mC;AACA,O;AACA,uB;AACA,I;AACA,sC;AACA,uE;AACA,qD;AACA,yD;AACA,I;AACA,oC;AACA,qD;AACA,8D;AACA,kF;AACA,+B;AACA,S;;AAEA,sB;AACA,mC;AACA,Q;;AAEA,6C;;AAEA,K;AACA,I;AACA,+C;;AAEA,oD;AACA,gD;;AAEA,yD;AACA,2C;AACA,+C;AACA,I;AACA,I;AACA,+B;AACA,6C;AACA,gD;AACA,+C;AACA,oD;AACA,wC;AACA,2C;AACA,2C;AACA,I;AACA,iC;AACA,kD;AACA,gD;AACA,6C;AACA,8C;AACA,4C;AACA,6C;AACA,+C;AACA,I;AACA,+C;AACA,mE;AACA,oD;AACA,gD;;AAEA,qC;AACA,I;AACA,+C;AACA,I;AACA,2C;;AAEA,+E;AACA,+C;AACA,mE;AACA,yC;;AAEA,sH;AACA,wC;AACA,gE;;AAEA,kJ;AACA,0F;AACA,mI;;AAEA,Y;AACA,0E;AACA,oH;;AAEA,4D;;AAEA,iC;;AAEA,2D;;AAEA,K;AACA,I;AACA,8B;AACA,0D;AACA,I;AACA,sB;AACA,2B;AACA,Y;AACA,6B;AACA,K;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;;;ACvJA,kE;AACA,G;AACA,Q;AACA,+D;AACA,+C;AACA,yD;AACA,G;AACA,6B;AACA,G;AACA,kE;;AAEA,iD;;AAEA,4C;AACA,2C;AACA,qD;;AAEA,wC;AACA,oC;;AAEA,qB;AACA,qC;AACA,oC;AACA,8C;;AAEA,wC;AACA,iB;;AAEA,M;AACA,mB;AACA,yD;AACA,yC;AACA,wC;AACA,oC;AACA,mC;AACA,yC;AACA,sC;AACA,W;AACA,S;AACA,O;AACA,M;AACA,uE;AACA,4C;AACA,wB;AACA,U;AACA,e;AACA,yC;AACA,U;AACA,O;;AAEA,K;AACA,G;;AAEA,kC;AACA,yB;;AAEA,C;;AAEA,2D;;AAEA,qC;AACA,iC;;AAEA,oJ;AACA,iE;AACA,mD;AACA,oB;AACA,yB;AACA,gC;AACA,qB;AACA,O;AACA,G;AACA,Q;AACA,kD;AACA,G;AACA,e;AACA,C;;AAEA,gB;AACA,gF;;AAEA,kC;AACA,gC;AACA,wC;;AAEA,6D;AACA,oC;;AAEA,iD;AACA,qB;AACA,Q;AACA,qB;AACA,O;;AAEA,wB;AACA,wD;AACA,6B;AACA,iE;AACA,a;AACA,K;;AAEA,4B;AACA,oC;AACA,4B;;AAEA,wG;AACA,kD;AACA,I;;AAEA,yB;;AAEA,sJ;AACA,M;AACA,mE;AACA,8E;AACA,mH;AACA,M;AACA,+B;AACA,uB;AACA,mC;AACA,sB;AACA,2B;AACA,kC;AACA,uB;AACA,S;AACA,M;AACA,a;AACA,K;;AAEA,oB;AACA,6B;AACA,uB;AACA,Q;AACA,qB;AACA,M;;AAEA,I;AACA,oE;;AAEA,kC;AACA,8B;AACA,iC;;;AAGA,6D;AACA,mF;AACA,wC;;AAEA,sB;AACA,2C;AACA,yC;AACA,yE;AACA,iD;AACA,gE;AACA,oD;AACA,+C;AACA,O;AACA,K;AACA,oB;AACA,I;AACA,0B;;AAEA,I;AACA,2D;;AAEA,kC;AACA,8B;;AAEA,6D;AACA,mF;;AAEA,sB;;AAEA,6B;;AAEA,uC;AACA,wC;;AAEA,uE;;AAEA,2B;AACA,M;AACA,K;;AAEA,I;AACA,yD;;AAEA,kC;AACA,gC;;AAEA,6D;AACA,qB;AACA,Q;AACA,mG;AACA,yC;AACA,sB;AACA,K;;AAEA,oC;;;AAGA,iB;AACA,Q;AACA,6D;AACA,I;AACA,iB;;AAEA,I;AACA,G;;;;;;;;;;;;;;;;;;;;;AChNA,sD;;AAEA,4E;AACA,qE;AACA,mD;;AAEA,kF;AACA,wF;AACA,8F;AACA,wD;AACA,0G;AACA,wF;AACA,6D;AACA,8F;;AAEA,iC;AACA,uD;AACA,oE;;;AAGA,8D;;AAEA,yD;AACA,kE;;AAEA,qB;;AAEA,kC;AACA,oC;AACA,uK;;AAEA,0G;;AAEA,wE;;AAEA,iG;;AAEA,0H;;AAEA,oH;;AAEA,4D;;AAEA,2C;;AAEA,oD;;AAEA,uE;AACA,0G;AACA,a;;AAEA,K;;AAEA,+C;;AAEA,uE;AACA,2B;AACA,qE;AACA,wG;AACA,O;AACA,4C;AACA,sC;AACA,a;;AAEA,K;;AAEA,sC;;AAEA,0D;AACA,yE;AACA,qD;AACA,8F;AACA,+D;AACA,iH;AACA,8B;;AAEA,K;;AAEA,mB;;AAEA,E;;AAEA,wC;;AAEA,6B;;AAEA,yB;AACA,64C;;AAEA,4G;AACA,mL;AACA,iE;;AAEA,2D;AACA,+B;AACA,6E;AACA,kC;AACA,wD;AACA,0I;AACA,8F;;AAEA,iB;;AAEA,kF;;AAEA,K","file":"/packages/msavin_mongol.js","sourcesContent":["MeteorToysDict = Package[\"meteortoys:toykit\"].MeteorToysDict;\n\nif (Mongol === undefined) {\n  \n  // Create object and reserve name across the package\n  Mongol = {};\n\n}\n\nMongol = {\n  'getDocumentUpdate': function (data) {\n    var elementID = 'MongolDoc_' + data,\n      newData = document.getElementById(elementID).textContent;\n\n    return newData;\n  },\n  'error': function (data) {\n    switch (data) {\n      case \"json.parse\":\n        alert(\"There is an error with your JSON syntax.\\n\\nNote: keys and string values need double quotes.\");\n        break;\n      case \"duplicate\":\n        alert(\"Strange, there was an error duplicating your document.\");\n        break;\n      case \"remove\":\n        alert(\"Strange, there was an error removing your document.\");\n        break;\n      case \"insert\":\n        alert(\"Strange, there was an error inserting your document.\");\n        break;\n      case \"update\":\n        alert(\"There was an error updating your document. Please review your changes and try again.\");\n        break;\n      default:\n        return \"Unknown Error\";\n        break;\n    }\n  },\n  'parse': function (data) {\n      var newObject = null;\n      try { \n        var reISO = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*))(?:Z|(\\+|-)([\\d|:]*))?$/;\n        var dateParser = function (key, value) {\n          if (_.isString(value)) {\n            var a = reISO.exec(value);\n            if (a) {\n              return new Date(value);\n            }\n          }\n          return value;\n        }\n        newObject = JSON.parse(data, dateParser);\n      }\n      catch (error) {\n        Mongol.error(\"json.parse\");\n      }\n      return newObject;\n  },\n  'setSubscriptionKeys': function () {\n      // var subscriptions  = Meteor.default_connection._subscriptions,\n      // subKeys        = Object.keys(subscriptions);\n      // MeteorToysDict.set(\"MeteorToys_PubSub\", subKeys)\n  },\n  'detectCollections': function () {\n    if (MeteorToysDict.get('Mongol') === undefined) {\n        // Note: this returns the actual mongo collection name\n        var collections = _.map(Mongo.Collection.getAll(), function (collection) {\n        return collection.name;\n      });\n\n      var defaults = {\n        'collections': collections,\n      };\n\n      MeteorToysDict.set(\"Mongol\", defaults);\n\n    }\n  },\n  'hideCollection': function (collectionName) {\n\n    var MongolConfig = MeteorToysDict.get(\"Mongol\"),\n        collections  = MongolConfig.collections;\n\n    collections = _.without(collections, collectionName);\n    MongolConfig.collections = collections;\n    MeteorToysDict.set(\"Mongol\", MongolConfig);\n    \n  },\n  'hideVelocity': function () {\n    this.hideCollection('velocityTestFiles');\n    this.hideCollection('velocityFixtureFiles');\n    this.hideCollection('velocityTestReports');\n    this.hideCollection('velocityAggregateReports');\n    this.hideCollection('velocityLogs');\n    this.hideCollection('velocityMirrors');\n    this.hideCollection('velocityOptions');\n  },\n  'hideMeteorToys': function () {\n    this.hideCollection(\"MeteorToys_Impersonate\");\n    this.hideCollection(\"MeteorToys_JetSetter\");\n    this.hideCollection(\"MeteorToys_Mongol\");\n    this.hideCollection(\"MeteorToys_AutoPub\");\n    this.hideCollection(\"MeteorToys_Email\");\n    this.hideCollection(\"MeteorToys_Result\");\n    this.hideCollection(\"MeteorToys_Throttle\");\n  },\n  'showCollection': function (collectionName) {\n    // In case a collection does not get detected, like a local one\n    var MongolConfig = MeteorToysDict.get(\"Mongol\"),\n        collections  = MongolConfig.collections;\n\n    collections.push(collectionName);\n    \n    MeteorToysDict.set(\"Mongol\", MongolConfig);\n  },\n  'Collection': function (collectionName) {\n\n    // Go through a variety of means of trying to return the correct collection\n    return Mongo.Collection.get(collectionName)\n      // This should automatically match all collections by default\n      // including namespaced collections\n\n    || ((Meteor.isServer) ? eval(collectionName) : Meteor._get.apply(null,[window].concat(collectionName.split('.'))))\n    // For user defined collection names\n    // in the form of Meteor's Mongo.Collection names as strings\n\n    || ((Meteor.isServer) ? eval(firstToUpper(collectionName)) : Meteor._get.apply(null,[window].concat(firstToUpper(collectionName).split('.'))))\n    // For user defined collections where the user has typical upper-case collection names\n    // but they've put actual mongodb collection names into the Mongol config instead of Meteor's Mongo.Collection names as strings\n\n    || null;\n    // If the user has gone for unconventional casing of collection names,\n    // they'll have to get them right (i.e. Meteor's Mongo.Collection names as string) in the Mongol config manually\n\n    // Changes the first character of a string to upper case\n\n    function firstToUpper(text) {\n\n      return text.charAt(0).toUpperCase() + text.substr(1);\n\n    }\n  },\n  'register': function(spec) {\n    originalSet = MeteorToysDict.get(\"Mongol_Extensions\");\n    \n    if (originalSet) {\n      originalSet = [spec];\n    } else {\n      originalSet.push(spec);\n    }\n  }\n}\n\n\n","// // // // // // // // // // // // // // // // // // // // // // \n// \n// TODO:\n// - For update, diff document changes and use $set for changes\n//   to control date fields from database level\n// - For duplicate, use actual MongoDB duplicate function\n// \n// Pull request welcome here!\n// \n// // // // // // // // // // // // // // // // // // // // // // \n\nvar dateParser = function (updatedDocumentData) {\n\n  // Purpose: Convert date strings to Date()\n  // This is hacky but works in most cases \n  // Won't merge into Mongol namespace until its good\n\n  currentDocument = updatedDocumentData;\n  revisedDocument = currentDocument;\n\n  // Loop over object\n  // Replace date strings with dates \n  for (var key in currentDocument) {\n    if (currentDocument.hasOwnProperty(key)) {\n\n      var t_self = currentDocument[key],\n          t_date;\n\n      \n      if (t_self) {\n        // check its a string to avoid hooking t/f values\n        if (typeof t_self === 'string') {\n        // ensure its not just a number \n        // need a stronger test here\n          if (/\\s/g.test(t_self)) {\n            // attempt to convert to date\n            t_date = new Date(t_self);\n          }\n        }\n      }\n      \n      if (Object.prototype.toString.call(t_date) === '[object Date]') {\n        if ( isNaN( t_date.getTime() ) ) {  \n           // do nothing\n         }\n         else {\n           revisedDocument[key] = t_date;\n         }\n      }\n\n    }\n  }\n\n  // return the processed document\n  return revisedDocument;\n\n}\n\nvar insertDoc = function (MongolCollection, documentData) {\n\n  check(MongolCollection, Match.Any);\n  check(documentData, Match.Any);\n\n  if (!!Package['aldeed:simple-schema'] && !!Package['aldeed:collection2'] && _.isFunction(MongolCollection.simpleSchema) && MongolCollection._c2) {\n    // This is to nullify the effects of SimpleSchema/Collection2\n    newId = MongolCollection.insert(documentData, {\n      filter: false,\n      autoConvert: false,\n      removeEmptyStrings: false,\n      validate: false\n    });\n  }\n  else {\n    newId = MongolCollection.insert(documentData);\n  }\n  return newId;\n}\n\nMeteor.methods({\n  Mongol_update: function (collectionName, documentData, originalDocumentData) {\n\n    check(collectionName, String);\n    check(documentData, Object);\n    check(originalDocumentData, Object);\n\n    var MongolCollection = Mongol.Collection(collectionName),\n      documentID = documentData._id;\n\n    var currentDbDoc = MongolCollection.findOne({\n      _id: documentID\n    }, {\n      transform: null\n    });\n\n    if (!currentDbDoc) {\n      // A document with this _id value is not in the db\n      // Do an insert instead\n      Meteor.call(\"Mongol_insert\", collectionName, documentData);\n      return;\n    }\n\n    delete documentData._id;\n    delete originalDocumentData._id;\n    delete currentDbDoc._id;\n\n    var updatedDocumentData = Mongol.diffDocumentData(currentDbDoc, documentData, originalDocumentData),\n        revisedDocument     = updatedDocumentData;\n    \n\n    // Check for packages\n\n    if (!!Package['aldeed:simple-schema'] && !!Package['aldeed:collection2'] && _.isFunction(MongolCollection.simpleSchema) && MongolCollection._c2) {\n      \n      // This is to nullify the effects of SimpleSchema/Collection2\n      // Using `upsert` means that a user can change the _id value in the JSON\n      // and then press the 'Update' button to create a duplicate (published keys/values only) with a different _id\n      \n      MongolCollection.update({\n        _id: documentID\n      }, {$set: revisedDocument}, {\n        filter: false,\n        autoConvert: false,\n        removeEmptyStrings: false,\n        validate: false\n      });\n      \n      return;\n    }\n\n    // Run the magic\n    MongolCollection.update({\n        _id: documentID\n      },\n      revisedDocument\n    );\n\n  },\n  Mongol_remove: function (collectionName, documentID, doNotTrash) {\n\n    check(collectionName, String);\n    check(documentID, String);\n    check(doNotTrash, Match.Any);\n\n\n    var MongolCollection = Mongol.Collection(collectionName);\n    var docToBeRemoved   = MongolCollection.findOne(documentID, {transform: null});\n    MongolCollection.remove(documentID);\n\n    // Start Trash Can\n    if(typeof doNotTrash === 'undefined') {\n      if (Package[\"meteortoys:toypro\"]) {\n        targetCollection        = Mongol.Collection(\"MeteorToys_Mongol\");\n        trashDocument           = docToBeRemoved;\n        trashDocument[\"Mongol_origin\"] = String(collectionName);\n        trashDocument[\"Mongol_date\"]   = new Date();\n        targetCollection.insert(trashDocument);\n      }\n    }\n    // End Trash Can\n    \n    return docToBeRemoved;\n\n  },\n  Mongol_duplicate: function (collectionName, documentID) {\n\n    check(collectionName, String);\n    check(documentID, String);\n\n    var MongolCollection = Mongol.Collection(collectionName),\n        OriginalDoc      = MongolCollection.findOne(documentID, {transform: null});\n\n    if (OriginalDoc) {\n\n      delete OriginalDoc._id;\n\n      // Convert date strings to Date()\n      var revisedDocument = OriginalDoc;\n\n      var NewDocumentId = insertDoc(MongolCollection, revisedDocument);\n\n      return NewDocumentId;\n      \n    }\n\n  },\n  Mongol_insert: function(collectionName, documentData) {\n\n    check(collectionName, String);\n    check(documentData, Object);\n\n    var MongolCollection = Mongol.Collection(collectionName),\n        newId = null;\n        \n    if (documentData._id && MongolCollection.findOne({_id: documentData._id}, {transform: null})) {\n      console.log('Duplicate _id found');\n      return null;    \n    }\n\n    revisedDocument = documentData; \n\n\n    // Insert it \n        \n    var newId = insertDoc(MongolCollection, revisedDocument);\n    \n    return newId;\n\n  },\n});\n\n\n","// This function takes three data points into account:\n\n// 1) the actual document as it stands on the server, prior to being updated\n// 2) the oldData that was on the client before the user pressed save\n// 3) the newData that the client is trying to save\n\n// This function decides which fields it is going to make writes to on this basis:\n// 1) The field(s) being overwritten must appear in the db doc and on the client oldData\n//    (if they only appear in the oldData these must have been added dynamically on the client\n//     and we don't want to save these fields to the db)\n//    -- this includes fields that are being removed (i.e. they must appear in the db doc and the oldData)\n// 2) Only fields that appear in the newData, but not the oldData or db doc can be added\n//    (if it appears in the db doc, throw an error that says:\n//     \"There is an unpublished field in the database with that name. Update cannot be made.\")\n\n// The ramifications of all this:\n// You can only update/remove fields that are published\n// You can only add new fields if they don't exist in the db already\n\n\nMongol.diffDocumentData = function (dbDoc, newData, oldData) {\n\n  // TODO -- recurse into subdocuments, performing checks\n  // using the Meteor._get function (as seen in /common/common.js)\n\n  var finalData = {};\n\n  var dbDocFields = _.keys(dbDoc),\n    newDataFields = _.keys(newData),\n    oldDataFields = _.keys(oldData); // console.log(\"dbDocFields\",dbDocFields); console.log(\"newDataFields\",newDataFields); console.log(\"oldDataFields\",oldDataFields);\n\n  // First get the set of fields that we won't be saving because they were dynamically added on the client\n\n  var dynamicallyAddedFields = _.difference(oldDataFields, dbDocFields);\n\n  // The get the fields that must retain their dbDoc field value, because they we'ren't published\n\n  var unpublishedFields = _.difference(dbDocFields, oldDataFields); // console.log(\"unpublishedFields\",unpublishedFields);\n\n  // iterate over all fields, old and new, and ascertain the field value that must be added to the final data object\n\n  var oldAndNewFields = _.union(dbDocFields, newDataFields);\n\n  _.each(oldAndNewFields, function(field) {\n\n    if (_.contains(dynamicallyAddedFields, field)) {\n\n      // We don't want to add this field to the actual mongodb document\n      console.log(\"'\" + field + \"' appears to be a dynamically added field. This field was not updated.\");\n      return;\n\n    }\n\n    if (_.contains(unpublishedFields, field)) {\n\n      // We don't want to overwrite the existing mondodb document value\n      if (newData[field]) {\n        // Give a message to user as to why that field wasn't updated\n        console.log(\"'\" + field + \"' is an unpublished field. This field's value was not overwritten.\");\n      }\n      // Make sure the old value is retained\n      finalData[field] = dbDoc[field];\n      return;\n\n    }\n\n    finalData[field] = newData[field];\n\n    // This will let unpublished fields into the database,\n    // so the user may be confused by the lack of an update in the client\n    // simply because the added field isn't published\n    // The following solves that problem, but doesn't allow new fields to be published at all:\n    //     finalData[field] = oldData[field] && newData[field];\n    // We actually need to know the set of fields published by the publication that the client side doc came from\n    // but how do we get that?\n\n  });\n\n  return finalData;\n\n};\n\n// Test code for Mongol.diffDocumentData\n\n/*Meteor.startup(function() {\n\n  // Take a user document\n  var sampleDbDoc = { \"_id\" : \"exampleuser1\", \"createdAt\" : 1375253926213, \"defaultPrograms\" : { \"514d75dc97d9562095578800\" : \"MYP\", \"515be9e6a57068c708000000\" : \"PYP\" }, \"department_id\" : [  \"GMsv9YzaCuL6dFBYL\" ], \"emails\" : [  {  \"address\" : \"babrahams@wab.edu\",  \"verified\" : true } ], \"myCourses\" : [  \"QqofG3XyEtQPgFb72\",  \"fvTxhAyfMxFbhzwK7\",  \"jcPtgwN2t6pTMQDEp\" ], \"organization_id\" : [  \"51f76bcb45623dfb1e0d3100\" ], \"permContexts\" : [ \t{ \t\"department_id\" : \"GMsv9YzaCuL6dFBYL\", \"perms\" : [ \t\"editRoles\", \t\"editCourses\", \t\"editUnits\", \t\"editAssessments\", \t\"editDepartments\" ] } ], \"roleContexts\" : [ \t{ \t\"organization_id\" : \"51f76bcb45623dfb1e0d3100\", \t\"school_id\" : \"514d75dc97d9562095578800\", \t\"department_id\" : \"GMsv9YzaCuL6dFBYL\", \t\"roles\" : [ \t\"iQD4BhnB8PFWwHCcg\" ] }, \t{ \t\"organization_id\" : \"2BjJbMyRLWa4iofQm\" } ], \"school_id\" : [  \"514d75dc97d9562095578800\" ], \"services\" : { \"password\" : { \"bcrypt\" : \"$2a$10$M55xiZA6rX0EwZ6xBk3Rre6/J5s3XUunre5.5ijyU3.ilpYZQFmtO\" }, \"resume\" : { \"loginTokens\" : [ \t{ \t\"when\" : \"2014-12-24T12:00:06.725Z\", \t\"hashedToken\" : \"not/telling=\" }, \t{ \t\"when\" : \"2015-01-16T04:45:10.574Z\", \t\"hashedToken\" : \"bigbadhashedtoken=\" }, \t{ \t\"when\" : \"2015-01-22T02:01:57.671Z\", \t\"hashedToken\" : \"9HSCRUygOiPYgmUsmWA5jcYutqKnjT9OByHPA6LbBB8=\" } ] } }, \"superuser\" : [  \"51f76bcb45623dfb1e0d3100\",  \"2BjJbMyRLWa4iofQm\",  \"ZkeRkDEEcp72bAFQY\" ], \"transaction_id\" : \"shQ9fzcZYSgLLnptC\" };\n\n  // Simulate the oldData getting sent back from the client (the fields should be a subset of the db fields)\n  var sampleOldData = _.extend(_.clone(sampleDbDoc),{dynamicallyAddedField:true, secondDynamicallyAddedField: \"Dynamically added value\"}); // Simulate two dynamically added fields\n  delete sampleOldData.services; // Simulate an unpublished field\n\n  // Simulate the newData getting sent back from the client\n  // e.g. user adds a new field\n  var sampleNewData = _.extend(_.clone(sampleOldData),{brandNewField: true});\n  // brandNewField should be added\n  delete sampleNewData.createdAt; // This should be gone\n  sampleNewData.secondDynamicallyAddedField = \"Dynamically added value overwritten by user\"; // seconddynamicallyAddedField should be gone\n  sampleNewData.transaction_id = \"overwritten transaction id\"; // This field should be changed\n\n  // Run the test\n\n  console.log(Mongol.diffDocumentData(sampleDbDoc, sampleNewData, sampleOldData));\n\n});*/\n"]}